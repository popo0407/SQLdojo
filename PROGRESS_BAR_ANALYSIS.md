# プログレスバー表示問題 - 技術分析レポート

## 📋 問題の概要

**現象**: バックエンドが 1-2 分の SQL 処理を実行中、フロントエンドでプログレスバーが表示されない問題

**本質的な問題**: フロントエンドは API 完了を待ってからプログレスポーリングを開始するため、バックエンド処理が完了した後に 100%の状態でポーリングが始まる

## 🔍 根本原因分析

### 1. アーキテクチャの根本的な問題

**同期処理アーキテクチャ**

- `executeSqlOnCache` API が全処理完了を待ってからレスポンスを返す
- フロントエンドは API 応答を受信してから初めてポーリングを開始
- この間（1-2 分）にバックエンド処理が完了し、ポーリング開始時には既に 100%

```
[現在のフロー]
Frontend: API呼び出し ────[1-2分待機]────→ API応答受信 → ポーリング開始 → 即座に100%
Backend:  SQL処理開始 → [1-2分処理] → SQL完了 → API応答送信
```

### 2. ログから確認できる問題の証拠

**フロントエンドログ**:

```
[DEBUG-FRONTEND] ポーリング開始: セッション cache_hint0531_20251005231738_714
[DEBUG-FRONTEND] API応答受信: セッション cache_hint0531_20251005231738_714, 応答時間: 156.9ms, 進捗: 10030/10030 (100.0%), ステータス: completed
[DEBUG-FRONTEND] ポーリング終了: セッション cache_hint0531_20251005231738_714, 最終ステータス: completed
```

**バックエンドログでの確認点**:

- `.db-journal`ファイルの生成・削除タイミング
- SQL 実行開始から完了までの時間
- セッション作成からポーリング開始までの時間差

## 🛠 技術的な解決アプローチ

### A. 非同期処理アーキテクチャへの移行（推奨）

**目標フロー**:

```
Frontend: API呼び出し → 即座にsession_id受信 → ポーリング開始 → リアルタイム進捗表示
Backend:  session_id即座返却 → バックグラウンドでSQL処理 → 進捗更新
```

**必要な変更**:

1. **バックエンド API 分離**

   - `validate_and_prepare_session()`: 軽量検証、即座に session_id 返却
   - `execute_sql_background()`: FastAPI BackgroundTasks で SQL 実行
   - 進捗状況の動的更新機能

2. **フロントエンド対応**
   - 一時的ポーリング（API 実行中の仮進捗表示）
   - session_id 受信後の実際のポーリング切り替え
   - ポーリング重複の防止

### B. 一時的解決策（シンプルアプローチ）

**フロントエンドのみの変更**:

- API 呼び出し開始と同時に仮のプログレスバー表示
- バックエンド処理推定時間に基づく仮進捗更新
- API 完了後に実際の結果表示

## 📊 実装時の技術的課題

### 1. セッション管理の複雑性

**課題**:

- CacheService でのセッション状態管理
- StreamingStateService との連携
- メモリと DB 間での状態同期

**解決策**:

- 統一されたセッションライフサイクル管理
- 適切なエラーハンドリングとクリーンアップ
- セッションタイムアウトの実装

### 2. 進捗計算の精度

**課題**:

- SQL 実行前の総件数推定
- カーソルベース処理での進捗計算
- 大容量データでのメモリ効率

**解決策**:

- `COUNT(*)`による事前集計（軽量化）
- バッチ処理での段階的進捗更新
- ストリーミング処理との組み合わせ

### 3. エラーハンドリング

**課題**:

- バックグラウンド処理でのエラー伝播
- フロントエンドでのタイムアウト処理
- 部分的失敗の処理

**解決策**:

- 包括的なエラー状態管理
- 適切なフォールバック機構
- ユーザーフレンドリーなエラーメッセージ

## 🎯 実装優先順位

### Phase 1: 最小限の非同期対応

1. `execute_sql_with_cache_endpoint`での BackgroundTasks 使用
2. 基本的な session_id 即座返却
3. フロントエンドでの一時的ポーリング実装

### Phase 2: 進捗精度向上

1. 実際の進捗計算ロジック実装
2. ストリーミング状態管理の改善
3. エラーハンドリングの強化

### Phase 3: パフォーマンス最適化

1. キャッシュ戦略の最適化
2. メモリ使用量の最適化
3. 大容量データ処理の改善

## 🔧 検証方法

### 1. 動作確認手順

**テストシナリオ**:

1. 1-2 分かかる SQL（大容量データ）を実行
2. フロントエンドでプログレスバーが即座に表示されることを確認
3. 実際の処理進捗がリアルタイムで更新されることを確認
4. 処理完了まで適切に表示が継続することを確認

**確認ポイント**:

- バックエンドログでバックグラウンド処理開始を確認
- フロントエンドログでポーリング開始タイミングを確認
- `.db-journal`ファイルの生成タイミングと進捗表示の同期

### 2. パフォーマンス測定

**測定項目**:

- session_id 返却までの時間（目標: <500ms）
- 初回進捗更新までの時間（目標: <1 秒）
- 進捗更新間隔の一貫性（目標: 200-500ms 間隔）

## 📝 実装上の注意点

### 1. 既存機能への影響

**互換性確保**:

- 既存のテストケースが継続して動作すること
- 同期処理を期待する部分でのフォールバック
- エラーケースでの適切な動作

### 2. リソース管理

**メモリ効率**:

- 長時間実行での メモリリーク防止
- セッション数の制限と管理
- 適切なガベージコレクション

### 3. ユーザビリティ

**UX 考慮事項**:

- プログレスバーの視覚的なフィードバック
- 処理中断（キャンセル）機能
- 適切な処理時間の推定表示
