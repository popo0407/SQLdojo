## **AI 開発エージェントのためのシステム設計・開発憲章**

この憲章は、将来の技術的負債を最小限に抑え、保守性と拡張性に優れたアプリケーションを継続的に開発するための基本原則を定める。AI エージェントは、すべてのコーディング、機能追加、リファクタリングにおいて、以下のルールを最優先で遵守すること。

### **最上位原則**

- AI の内部思考は**英語**、AI 同士の会話、外部への回答・ドキュメントは**日本語**。
- 開発憲章の全文を確認し開発憲章に従って処理をすること
- 不明点がある場合は、作業開始前に必ず確認を取ること。
- Agent 起動時に`cursor.md`の全体を読み込み、最上位原則を全てチャット上に表示する。
- すべてのタスクが完了したら、以下の原則に反していないかチェックし、確認を取った上で README.md の更新と github への add commit push をすること。
- すべてのタスク完了時には、発生したバグや問題点を振り返り、「なぜ発生したか」「開発憲章に従っていれば防げたか」を必ず自己レビューすること。必要に応じて憲章自体の改善案を検討し、次回以降の品質向上に活かすこと。

### **リスクベースアプローチ：開発速度と品質のバランス**

すべての変更に同じ厳格さを求めるのではなく、変更の**影響範囲とリスク**に応じて手続きの重みを変えることで、開発速度と品質のバランスを最適化する。

#### **高リスク変更：憲章の全ルールを厳密適用**

- **対象**: コアロジック、共有モジュール、設定ファイル、認証システム、データベーススキーマなど、広範囲に影響する変更
- **適用ルール**: 憲章の全ルール（特に影響範囲分析、テスト駆動、段階的移行、ドキュメント更新）を厳密に適用
- **プロセス**: 事前の影響範囲分析、テスト作成、段階的移行計画、詳細なドキュメント更新が必須

#### **中リスク変更：基本原則のみ遵守**

- **対象**: 既存機能のバグ修正、単一 API エンドポイント内のロジック改善、既存サービスの機能拡張など
- **適用ルール**: 「本番機能の保護」「テストの徹底」「差分レビュー」の基本原則を遵守
- **プロセス**: 影響範囲の確認、関連テストの実行、ドキュメント更新が必須

#### **低リスク変更：軽量プロセス**

- **対象**: UI の文言修正、CSS の微調整、コメントの追加、軽微なログ出力の変更など、ロジックに影響しない変更
- **適用ルール**: 基本的な品質チェックのみ
- **プロセス**: `git status`と`git diff`で変更範囲を確認し、セルフレビュー後に直接コミット。PR は不要、もしくは事後報告でも可

### **開発プロセス標準化：品質と効率の両立**

高リスク、中リスクの開発作業は以下の 6 ステッププロセスに従って実行すること：

1. **指示の分析と計画**: 要求を詳細に分析し、実装方針と影響範囲を明確化する
2. **事前協議**: 開発憲章を準拠した実装方針を検討する
3. **方針決定**: ユーザーからの回答を考慮して改善方針を決定する
4. **段階的実装**: 小さな単位で実装し、各段階でテストを行う
5. **問題特定と修正**: テストで発見した問題を体系的に分析し、ログで検証して根本原因を特定して修正する
6. **振り返りと改善**: 完了後は発生した問題を分析し、憲章の改善案を検討する

このプロセスにより、品質の一貫性を保ちながら開発速度を最適化する。

-----

### I. 基本設計原則：すべてのコードの礎

1.  **単一責任の原則 (Single Responsibility Principle - SRP) を徹底せよ**

      - **Do**: 1つのクラス、1つの関数には、1つの明確な役割だけを持たせること。API通信、データ処理、UI更新などの複数の役割を混在させず、責務が多すぎる兆候（クラスのコードが500行を超えるなど）を避けること。

2.  **関心の分離 (Separation of Concerns - SoC) を意識せよ**

      - **Do**: アプリケーションを、プレゼンテーション層（UI）、ビジネスロジック層（Service）、データアクセス層（Repository）といった、関心事の異なるレイヤーに明確に分割し、各層の責務を厳格に守ること。（例：プレゼンテーション層にデータアクセス層のロジックを記述しない）

3.  **繰り返しを避ける (Don't Repeat Yourself - DRY) ことを心掛けよ**

      - **Do**: 複数の場所で同じコードブロックが出現した場合、それを共通の関数やクラスに括り出し、再利用可能な形にリファクタリングすること。コピー＆ペーストによるコードの重複は、将来の修正漏れやバグの温床となるため、避けること。

4.  **設定とロジックを分離せよ**

      - **Do**: データベース接続情報、APIキー、環境変数といった設定値は、コードから分離された設定ファイル（例：`.env`, `config.py`）で管理し、コード内に環境依存の値をハードコーディングしないこと。

5.  **変更は、関連する全てのコンポーネントで一貫性を保て**

      - **Do**: 一つの機能変更やリファクタリングを行う際は、その影響が及ぶすべての範囲（ロジック、データベーススキーマ、API定義、テストコード）を特定し、一度のコミットで全ての整合性が取れた状態にすること。

-----

### II. フロントエンドの規約：ユーザー体験と保守性の両立

6.  **コンポーネントベースでUIを構築せよ**

      - **Do**: UIを再利用可能な独立した部品（コンポーネント）の集合として設計すること。サイドバー、結果テーブル、ボタン群などは、それぞれが自己完結したコンポーネントであるべき。

7.  **状態管理を一元化せよ**

      - **Do**: アプリケーション全体で共有される状態（例: ユーザー情報、APIから取得したデータ）は、単一のストアで管理すること。状態の変更は、必ず定義された手順（ActionやMutation）を経て行い、コンポーネントはストアから状態を受け取って表示することに専念すること。

8.  **UIの状態管理をコンポーネントに閉じてカプセル化せよ**

      - **Do**: UIの表示状態（例：モーダルの開閉、タブの選択状態）は、可能な限りそのUIを管理するコンポーネントの内部状態として保持すること。

9.  **ビジネスロジックとDOM操作を分離せよ**

      - **Do**: DOMを直接操作するコードは、専用のUIサービスまたはコンポーネント内に閉じ込めること。ビジネスロジックは「データを更新する」ことだけを考え、UIサービスがそのデータ変更を検知して画面を再描画する、というデータ駆動の設計を心掛けること。

10. **クライアントサイド・キャッシュを積極的に活用し、体感速度とサーバー負荷を改善せよ**

      - **Do**: 頻繁に参照されるがリアルタイム性が必須ではないデータ（例：操作履歴、マスターデータ）は、`sessionStorage`や`localStorage`といったブラウザのキャッシュ機能を活用すること。ページ読み込み時はまずキャッシュから表示し、ユーザーの明示的な操作（例：「更新」ボタン）によってサーバーから最新データを取得するアーキテクチャを基本とせよ。

11. **ユーザビリティを最優先に設計せよ**

      - **Do**:
          - エラーメッセージは具体的で分かりやすく、解決方法を含めること（例：「WHERE句が必要です…」）
          - 成功メッセージは、ユーザーが見た目で成功がわかる場合は表示しないこと。
          - 通知の色は目に優しく、エラーは淡い色を使用すること。
          - 通知は即座に消去できるようにし、不要な遅延を避けること。
          - ユーザーの操作結果は視覚的に明確にフィードバックすること。

12. **コンポーネントの配置は、その役割に応じて決定せよ**

      - **Do**: 新しいコンポーネントを作る際は「この部品は他の画面でも使い回せるか？」と自問し、以下の基準で配置場所を決定すること。
          - **`components/`**: 再利用可能な汎用部品（UIに特化し、ビジネスロジックに依存しない）を配置する。（例: `Button`, `Input`, `Modal`, `Table`）
          - **`features/`**: `components/`の部品を組み合わせ、状態（ストア）と連携して特定の機能を実現するコンポーネントを配置する。（例: `UserList`, `ResultsDisplay`）

13. **コンポーネントは、必要最小限のストアのみを購読せよ**

      - **Do**: コンポーネントが状態を参照する際は、その仕事に必要最小限のデータだけを受け取ること。Facadeストアの安易な利用は避け、原則として具体的なストアを直接利用し、パフォーマンス低下を防ぐこと。

-----

### III. バックエンドの規約：堅牢性と拡張性の確保

14. **依存性注入 (DI) を徹底し、レイヤーを疎結合に保て**

      - **Do**: 上位レイヤーは、下位レイヤーの具体的な実装ではなく、抽象（インターフェースや基底クラス）に依存すること。依存関係は、コンストラクタやFastAPIの`Depends`のようなフレームワークの機能を通じて外部から注入する。

15. **サービスの責務を厳格に定義せよ**

      - **Do**:
          - **API層 (Controller/Router)**: HTTPリクエストを受け取り、バリデーションを行い、適切なServiceを呼び出して、結果をHTTPレスポンスとして返すことだけに責任を持つ。
          - **ビジネスロジック層 (Service)**: アプリケーション固有のルールやデータ処理フローを実装する。
          - **データアクセス層 (Repository/DAO)**: データベースや外部APIとの具体的なやり取りのみを担当する。

16. **モジュールは機能単位で分割せよ**

      - **Do**: `routes.py`などが肥大化しないよう、関連するAPIエンドポイントは`APIRouter`を使って機能ごと（例: `user_routes.py`, `template_routes.py`）にファイルを分割すること。ServiceやRepositoryも同様に分割する。

17. **複数の責務を束ねる統括サービス（Facade）で、ビジネスロジックを抽象化せよ**

      - **Do**: ビジネス上の一つの操作が複数の下位サービスの呼び出しを必要とする場合、それらを統括する上位のサービス（例：`AdminService`）を設けること。API層はこの統括サービスにのみ依存させ、複雑な処理フローはAPIルート関数内ではなく、この統括サービス内にビジネスロジックとして実装すること。

18. **ログは階層と目的を意識し、意図を持って記録せよ**

      - **Do**: ログのレベル（INFO, DEBUG等）を、その情報が誰にとっていつ必要かに基づいて使い分けること。関数は処理結果を戻り値として返し、ログ出力の判断は呼び出し元（主に最上位のサービス）に委ね、各階層から無秩序にINFOログを出力しないこと。
          - **INFO**: ビジネスレベルの大きな処理単位の開始と完了を示すために使う。
          - **DEBUG**: 開発者が処理の流れを追跡するための、システム内部の具体的なステップを示すために使う。

-----

### IV. テストと品質の規約：未来の自分を助けるために

19. **テスト容易性を意識して設計せよ**

      - **Do**: 関数はできるだけ副作用のない純粋関数として設計すること。クラスの依存関係は外部から注入できるようにし、テスト時には簡単にモックに差し替えられるように設計すること。

20. **テストコードにもDRY原則を適用せよ**

      - **Do**: 複数のテストで共通するセットアップ処理（例: テスト用データの作成、DB接続のモック化）は、テストフレームワークの共通化機能（例: `pytest`の`fixture`）に括り出すこと。

21. **例外・エラー時の安全なフォールバックとユーザー確認**

      - **Do**: 設定が壊れている・DBが空など異常系でも安全なデフォルト動作を保証すること。エラーや例外時の動作が明確でない場合は、必ずユーザーに確認・問いかけて方針を決定すること。

-----

### V. リファクタリングの規約：安全なコード進化のために

22. **本番機能の絶対保護を最優先とせよ**

      - **Do**: リファクタリングは、既存の本番機能の動作を完全に維持したまま行うこと。モックや仮実装は、テストコード内に厳密に隔離し、本番コードの振る舞いを変更しないこと。

23. **テストによる振る舞いの保証を徹底せよ**

      - **Do**: リファクタリング対象の振る舞いを検証するテストを事前に作成・確認し、リファクタリング後はそのテストがすべて成功することを必ず検証すること。

24. **影響範囲の徹底的な特定と管理を怠るな**

      - **Do**: 変更に着手する前に、クラス、関数、変数など、変更対象が参照されている箇所をすべて（テストコードも含め）洗い出し、矛盾なく修正すること。

25. **変更は小さく、段階的に進めよ**

      - **Do**: 大きなリファクタリングは、意味のある小さな単位に分割し、コミットやプルリクエストを分けること。各ステップで動作確認とレビューを実施すること。

26. **後方互換性を意識した段階的移行を計画せよ**

      - **Do**: 既存の機能（API、クラス等）を置き換える際は、まず新しい機能を追加し、両者が並行稼働する期間を設けること。すべての呼び出し元が新しい機能へ移行したことを確認した上で、古い機能を削除すること。

27. **設定変更は環境の互換性を維持せよ**

      - **Do**: 設定クラスや環境変数を変更する際は、既存の`.env`ファイルでもシステムがエラーなく起動するように、エイリアスやデフォルト値などを活用して互換性を保つこと。`env.example`の更新を忘れないこと。

28. **変更の意図と結果を明確に記録せよ**

      - **Do**: なぜそのリファクタリングが必要だったのか、どのような変更を行ったのかを、コミットメッセージやプルリクエスト、関連ドキュメントに明確に記述すること。「修正」のような曖昧なメッセージは避けること。

29. **異常発生時は即座にロールバックせよ**

      - **Do**: リファクタリング中に予期せぬエラーが発生した場合や、テストが失敗した場合は、即座に作業を中断し、変更を元に戻す（ロールバックする）こと。原因究明はその後に落ち着いて行うこと。

30. **暫定処理を避け、抽象化による根本解決を優先せよ**

      - **Do**: 外部サービス（データベース、API等）の障害や制限に直面した場合、ダミーデータや仮実装による暫定処理は行わず、ユーザーに対応を確認すること。技術的負債を将来に先送りするような一時的な解決策は採用しないこと。

31. **抽象化レイヤーの設計原則**

      - **Do**:
          - **インターフェース分離**: 外部依存関係（DB、API等）は必ずインターフェースで抽象化し、具体的な実装は注入可能にすること。
          - **設定駆動**: 環境変数や設定ファイルで動作を制御し、コード変更なしで切り替え可能にすること。
          - **段階的移行**: 新しい実装は既存の実装と並行稼轍させ、段階的に移行すること。
          - **障害分離**: 一つの外部依存関係の障害が他の機能に影響しないよう、適切な境界を設けること。

# ショートカットエイリアス

- `/ask`: ユーザーがポリシーに関する相談を求めている場合。多角的な分析を含む積極的な回答を提供してください。明確な指示がない限り、相談中にタスクを実行しないでください。
- `/plan`: 作業計画を明確かつ詳細に概説し、相違点がないことを確認してください。合意に達した後にのみ実行に移ってください。
- `/debug`: バグの根本原因を特定します。5〜7 つの可能性のある原因をリストアップし、1〜2 つに絞り込みます。修正を適用する前に、ログを使用して仮説を検証してください。
- `/cmt`: コードの意図を明確にするために、適切なコメントとドキュメントを追加します。既存のコード形式に従ってください。
- `/log`: 適切なログレベルを考慮し、必要な情報のみを記録します。ログは簡潔に設計し、冗長性を避けてください。既存のコード形式に従ってください。
